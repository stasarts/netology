Win 10 Home, работа в Windows Terminal.
ВМ ubuntu 20.04 разворачивается (Vagrant+VirtualBox):
vagrant init bento/ubuntu-20.04
vagrant up
vagrant ssh

1) Узнать какого типа команда cd:
$ type cd
cd is a shell builtin
Команда cd - встроенная команда shell. По моему мнению она является встроенной, т.к. реализует "базовый" функционал - навигацию по файловой системе. Этот функционал необходим сразу при входе в систему (после загрузки оболочки), без дополнительной установки.

2) Альтернатива без pipe команде grep <some_string> <some_file> | wc -l:
$ grep -c <some_string> <some_file>
Флаг -c подавляет обычный вывод; вместо этого выводится количество совпадающих строк для каждого входного файла.

3) Родителем для всех процессов с PID 1 является процесс init (systemd). Это менеджер систем и служб для операционных систем Linux. При запуске от имени первого процесса при загрузке (как PID 1) он действует как система инициализации, которая запускает и поддерживает службы пользовательского пространства.
Отдельные экземпляры запускаются для зарегистрированных пользователей, чтобы запустить их службы.
systemd обычно не вызывается пользователем напрямую, но устанавливается как символическая ссылка /sbin/init и запускается во время ранней загрузки.

4) Команда, которая перенаправит вывод stderr ls на другую сессию терминала:
$ ls 2> /dev/pts/<x> # где <x> - номер сессии терминала

5) Одновременно передать команде файл на stdin и вывести ее stdout в другой файл:
grep <strSearchFor> < <filename> > <fileForStdOut>
Явное указание stdin "<" в данном примере "избыточно". Большинство команд могут принимать stdin из файла без явного указания.

6) Получится.
Запустим несколько сессий с помощью команды vagrant ssh (в разных терминалах).
$ tty # определим номер сессии в первом терминале
/dev/pts/0
$ tty # определим номер сессии во втором терминале
/dev/pts/1
$ echo "hello from another tty" > /dev/pts/1 # отправим приветствие из первого терминала во второй
hello to another tty # увидим во втором терминале

7) Команда bash 5>&1 направит файл дескриптор 5 в stdout bash. Т.о. если выполнить команду echo netology > /proc/$$/fd/5, то мы увидим в текущем терминале вывод "netology".
$ bash 5>&1 # выполним команду
$ ll /proc/self/fd # посмотрим, что у bash появился файл дескриптор с выводом в текущего терминала.
total 0
dr-x------ 2 vagrant vagrant  0 Nov 15 09:13 ./
dr-xr-xr-x 9 vagrant vagrant  0 Nov 15 09:13 ../
lrwx------ 1 vagrant vagrant 64 Nov 15 09:13 0 -> /dev/pts/0
lrwx------ 1 vagrant vagrant 64 Nov 15 09:13 1 -> /dev/pts/0
lrwx------ 1 vagrant vagrant 64 Nov 15 09:13 2 -> /dev/pts/0
lr-x------ 1 vagrant vagrant 64 Nov 15 09:13 3 -> /proc/1142/fd/
lrwx------ 1 vagrant vagrant 64 Nov 15 09:13 5 -> /dev/pts/0
$ echo netology > /proc/$$/fd/5 # направить netology в fd5
netology

8) Получится.
$ bash 5>&1 # пепенаправим fd5 в stdout
$ ls netology-practice netology 2>&1 1>&5 | grep fi # директория "netology-practice" существует и ls вернет ее содержимое, директория "netology" не существует - ls вернет ошибку, которая направится в pipe. grep отработает только на ошибке, подсветив file только в третьей строке вывода.
netology-practice:
hw32  testfile  testfile1
ls: cannot access 'netology': No such file or directory

9) Команда cat /proc/$$/environ выведет значения переменных среды. Аналогичный по содержанию вывод можно получить командой printenv.

10) По адресу /proc/<PID>/cmdline - файл только для чтения, который содержит полную командную строку для процесса, если только процесс не является зомби. В последнем случае в этом файле ничего нет: то есть чтение этого файла вернет 0 символов.
По адресу /proc/<PID>/exe - В Linux 2.2 и более поздних версиях этот файл представляет собой символическую ссылку, содержащую фактический путь к выполняемой команде.

11) $ grep sse /proc/cpuinfo
Наиболее старшую версию набора инструкций SSE, которую поддерживает процессор: sse4_2.

12) Выполним предложенный пример:
$ ssh localhost tty
vagrant@localhost's password:
not a tty
Когда выполнение команд запускается на удаленных хостах, по умолчанию, они не выполняются в терминале (терминал не выделяется). Но этом примере мы пытаемся выполнить команду shell, для которой нужен терминал. 
Чтобы изменить данное поведение, нужно передать дополнительно опцию -t для принудительно выделения терминала. Используется для выполнения произвольных команд в интерактивном режиме на удаленной машине. 
$ ssh -t vagrant@localhost tty
vagrant@localhost's password:
/dev/pts/1
Connection to localhost closed.

13) Установим reptyr:
$ sudo apt-get install reptyr
$ nano /etc/sysctl.d/10-ptrace.conf # для того, чтобы он работал в ubuntu, нужно выставить kernel.yama.ptrace_scope = 0 в файле /etc/sysctl.d/10-ptrace.conf.
$ top # запускаем длительный процесс, например top.
# переведем процесс top в фон с помощью ^Z
$ jobs -l # посмотрим PID процесса top (например, 1110)
$ screen # запустим терминальный мультиплексор screen (как альтернатива tmux)
$ reptyr 1110 # перенесем фоновый процесс top в screen
# отцепим screen с помощью ^a и затем d
# закроем ssh-сессию
$ vagrant ssh # откроем новую ssh-сессию
$ screen -r # переподцепим screen, в нем увидим выполняющийся процесс top

14) Команда tee читает данные из stdin и пишет их в stdout и файлы.
sudo echo string > /root/new_file - нет прав, т.к. перенаправление потока происходит под текущей оболочкой, без прав суперпользователя.
echo string | sudo tee /root/new_file - выполнится корректно, т.к. stdout echo направится через pipe на stdin tee, который выполнится с правами суперпользователя.