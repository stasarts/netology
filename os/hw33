Win 10 Home, работа в Windows Terminal.
ВМ ubuntu 20.04 разворачивается (Vagrant+VirtualBox):
vagrant init bento/ubuntu-20.04
vagrant up
vagrant ssh

1) Какой системный вызов делает команда cd?
$ strace -o strace-bash-cd-tmp /bin/bash -c 'cd /tmp' # запустим strace и направим вывод в файл для удобства просмотра (опция -o)
$ vi strace-bash-cd-tmp # откроем записанный файл для просмотра
# поищем путь, указанный в cd /tmp и найдем системный вызов
chdir("/tmp")                           = 0
# почитаем man 2 chdir

2) БД file на основании которой она делает свои догадки: /usr/share/misc/magic.mgc
Запишем вывод strace:
$ strace -o strace-file-tty file /dev/tty # для tty
$ strace -o strace-file-sda file /dev/sda # для sda
$ strace -o strace-file-bash file /dev/sda # для bash
# поищем в записанных файлах
$ vi strace-file-tty # поиск /tty
$ vi strace-file-sda # посик /sda
$ vi strace-file-bash # посик /bash
# увидим, что во всех случаях file обращается к /usr/share/misc/magic.mgc
# можно было просто прочитать это в man file

3) Основываясь на знаниях о перенаправлении потоков, предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).
Основываясь на знаниях о перенаправлении потоков, перенаправить поток уже запущенного процесса в другой fd невозможно.
Найденный способ обнуления открытого удаленного файла:
$ ping 10.0.2.15 >> ping_log # запустим процесс ping с выводом в файл
$ rm ping_log # удалим файл ping_log
$ sudo lsof | grep deleted # посмотрим удаленные открытые процессами файлы 
ping      46888                          vagrant    1w      REG              253,0     3578     131107 /home/vagrant/ping_log (deleted)
$ sudo lsof | grep deleted # убедимся, что размер файла растет (был 3578 байт, стал 20296 байт)
ping      46888                          vagrant    1w      REG              253,0    20296     131107 /home/vagrant/ping_log (deleted)
# видим, что процесс пишет файловый дескриптор 1 в удаленный файл
$ truncate -s 0 /proc/46888/fd/1 # из man truncate: уменьшает или увеличивает размер файла до указанного размера
# файл останется в файловой системе пока процесс не завершится, но размер файла будет 0 байт и место на диске высвободится
$ sudo lsof | grep deleted # посмотрим еще раз на удаленный файл
ping      46888                          vagrant    1w      REG              253,0      118     131107 /home/vagrant/ping_log (deleted)
# видим, что файл обнулился, но вывод ping продолжает писать в него (размер 118 байт)

4) Зомби процессы не занимают ресурсы в ОС (CPU, RAM, IO). Единственный ресурс, который удерживает зомби процесс - запись в таблице процессов (process ID).

5) opensnoop - отслеживает системный вызов open(), показывая, какие процессы пытаются открыть какие файлы. Это может быть полезно для определения местоположения файлов конфигурации и журналов или для устранения неполадок приложений, которые выходят из строя, особенно при запуске.
$ sudo opensnoop-bpfcc -d 1 # запустим с опцией -d отслеживать 1 секунду
PID    COMM               FD ERR PATH
775    vminfo              5   0 /var/run/utmp
601    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
601    dbus-daemon        18   0 /usr/share/dbus-1/system-services
601    dbus-daemon        -1   2 /lib/dbus-1/system-services
601    dbus-daemon        18   0 /var/lib/snapd/dbus-1/system-services/

6) Воспользуемся strace:
$ strace -o uname_log uname -a
$ vi uname_log # почитаем записанный файл
# uname -a использует системный вызов: uname({sysname="Linux", nodename="vagrant", ...}) = 0
# почитаем man 2 uname
# альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС: /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}

7) ; - просто разделяет последовательно идущие команды
&& - оператор, который используется для создания цепочек команд. command1 && command2. В этом случае command2 выполнится, только если command1 завершится с кодом 0
$ pwd
/home/vagrant
$ [[ `pwd` == /home/vagrant ]] && echo "OK" || echo "Not OK"
OK
$ [[ `pwd` == /home ]] && echo "OK" || echo "Not OK"
Not OK
$ [[ `pwd` == /home ]] ; echo "OK" ; echo "Not OK"
OK
Not OK
Если применить set -e, то смысл && теряется, т.к. в соответствии с set --help: -e немедленно завершает работу, если команда завершается с ненулевым статусом.

8) set --help
set -euxo pipefail состоит из опций:
-e  Немедленно завершать работу, если команда завершается с ненулевым статусом
-u  Рассматривать неустановленные переменные как ошибку при замене.
-x  Выводить команды и их аргументы по мере их выполнения.
-o pipefail  возвращаемое значение конвейера - это статус последней команды с ненулевым статусом выхода или ноль, если ни одна команда не вышла с ненулевым статусом
Этот режим хорошо использовать в сценариях при отладке. -e вместе с -o pipefail покажут на какой команде сценарий упал и код ошибки команды. -u покажет, если заданы не все переменные. -x покажет порядок выполнения команд.

9) Усовершенствуем вывод ps -o stat:
-e  выбрать все процессы
sort - отсортировать вывод
uniq -c - пропускать и считать повторяющиеся строки
$ ps -eo state | sort | uniq -c
     48 I
      1 R
     51 S
Из man ps /PROCESS STATE CODES:
I - бездействующие потоки ядра
R - работающие процессы или процессы в очереди на исполнение
S - "спящие" процессы, ожидающие события для завершения
Т.о. больше всего "спящих" процессов.